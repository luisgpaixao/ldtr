if(! class(df)== 'data.frame'){
df = data.frame( do.call(rbind, df) )
}
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
if(nrow(df) == 0){
return(NULL)
}
df = df_colNum(df)
if(nrow(df) == 0){
return(NULL)
}
reg_count = nrow(df)
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
df = df[!is.na(df$Lst),]
if(nrow(df)>0){
return(df)
}else{
return(NULL)
}
}
# caso existam mais que 1 produto, encontra o max valido para cada ponto
df = fromJSON(in_json[[1]]$data)
if(class(df)=='list'){
df = data.frame( do.call(rbind, df) )
}
if(! class(df)== 'data.frame'){
df = fromJSON(df)
}
if(! class(df)== 'data.frame'){
df = data.frame( do.call(rbind, df) )
}
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
df = df_colNum(df)
for(hour in 2:length(in_json)){
df_seq = fromJSON(in_json[[hour]]$data)
if(class(df_seq)=='list'){
df_seq = data.frame( do.call(rbind, df_seq) )
}
if(! class(df_seq)== 'data.frame'){
df_seq = fromJSON(df_seq)
}
if(! class(df_seq)== 'data.frame'){
df_seq = data.frame( do.call(rbind, df_seq) )
}
df_seq = df_colNum(df_seq)
colnames(df_seq) =  names_c
df_seq = subset_product(df_seq, input_shp)
if(nrow(df_seq) == 0){
return(NULL)
}
df_seq = df_colNum(df_seq)
if(nrow(df_seq) == 0){
return(NULL)
}
for(i in 1:nrow(df_seq)){
if(newP){
if((df_seq$Lst[i] > df$Lst[i]) & (df_seq$Qflag[i] %in% q_thresh2)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}else{
if((df_seq$Lst[i] > df$Lst[i]) & (df_seq$Qflag[i] >= q_thresh1)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}
}
}
colnames(df) = names_c
df = df_colNum(df)
reg_count = nrow(df)
# coordinates(df) = ~Lon+Lat
# mapview(df, na.color="red",
#         map.types=mapviewGetOption("basemaps")[4])
# writeOGR(df, "C:/Users/LGP/Desktop/tempSave/teste.shp", layer="teste.shp", driver = "ESRI Shapefile")
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
df = df[!is.na(df$Lst),]
if(nrow(df)>0){
return(df)
}else{
return(NULL)
}
}
MinLSTday_db_point = function(in_json, input_shp){
# se nao existirem produtos retorna NA
if(length(in_json)==0){
return(NULL)
}
# verifica data do produto para confirmar Quality Flag
if(as.Date(in_json[[1]]$date_product) >= as.Date("2021-04-26")){
newP = T
}else{
newP = F
}
# thesholds de qflags
q_thresh1 = 10000
q_thresh2 = c(101,102,301,302)
# se exitir 1 produto, retorna o mesmo
if(length(in_json)==1){
df = fromJSON(in_json[[1]]$data)
if(class(df)=='list'){
df = data.frame( do.call(rbind, df) )
}
if(! class(df)== 'data.frame'){
df = fromJSON(df)
}
if(! class(df)== 'data.frame'){
df = data.frame( do.call(rbind, df) )
}
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
if(nrow(df) == 0){
return(NULL)
}
df = df_colNum(df)
if(nrow(df) == 0){
return(NULL)
}
reg_count = nrow(df)
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
df = df[!is.na(df$Lst),]
if(nrow(df)>0){
return(df)
}else{
return(NULL)
}
}
# caso existam mais que 1 produto, encontra o max valido para cada ponto
df = fromJSON(in_json[[1]]$data)
if(class(df)=='list'){
df = data.frame( do.call(rbind, df) )
}
if(! class(df)== 'data.frame'){
df = fromJSON(df)
}
if(! class(df)== 'data.frame'){
df = data.frame( do.call(rbind, df) )
}
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
df = df_colNum(df)
for(hour in 2:length(in_json)){
df_seq = fromJSON(in_json[[hour]]$data)
if(class(df_seq)=='list'){
df_seq = data.frame( do.call(rbind, df_seq) )
}
if(! class(df_seq)== 'data.frame'){
df_seq = fromJSON(df_seq)
}
if(! class(df_seq)== 'data.frame'){
df_seq = data.frame( do.call(rbind, df_seq) )
}
df_seq = df_colNum(df_seq)
colnames(df_seq) =  names_c
df_seq = subset_product(df_seq, input_shp)
if(nrow(df_seq) == 0){
return(NULL)
}
df_seq = df_colNum(df_seq)
if(nrow(df_seq) == 0){
return(NULL)
}
for(i in 1:nrow(df_seq)){
if(newP){
if((df_seq$Lst[i] < df$Lst[i]) & (df_seq$Qflag[i] %in% q_thresh2)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}else{
if((df_seq$Lst[i] < df$Lst[i]) & (df_seq$Qflag[i] >= q_thresh1)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}
}
}
colnames(df) = names_c
df = df_colNum(df)
reg_count = nrow(df)
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
df = df[!is.na(df$Lst),]
if(nrow(df)>0){
return(df)
}else{
return(NULL)
}
}
pointSelect = function(in_df, json_Q){
if(!is.null(in_df)){
wkt = terra::vect(json_Q$lstPoint, crs = wgs)
# wkt = readWKT(json_Q$lstPoint)
# raster::crs(wkt) = "+init=epsg:4326"
sel = in_df
sel = terra::vect(sel, geom = c("Lon", "Lat"), crs = wgs, keepgeom = T)
# coordinates(sel) = ~Lon+Lat
# raster::crs(sel) = "+init=epsg:4326"
dist_pontos = terra::distance(sel, wkt, pairwise = F)
# dist_pontos = t(as.data.frame(dist_pontos))
# class(dist_pontos)
# dist_pontos / 111320
# dist_pontos = t(gDistance(sel, wkt, byid = T))
sel = as.data.frame(sel)
sel$Dist = dist_pontos
sel = sel[order(sel$Dist), ]
if(nrow(sel)>4){
sel = sel[1:4,]
}
avr = mean(sel$Lst)
count = length(sel$Lst)
if(count>1){
sd = sd(sel$Lst)
}else{
sd = NULL
}
return(list(Mean = avr, SD = sd, Count = count))
}else{
return(list(Mean = NULL, SD = NULL, Count = NULL))
}
}
finalDataFrame=function(json_Q, buff){
tryCatch(
expr = {
input_shp = GetWkt_point(json_Q, buff)
print("WKT Done")
factor = getTZdif_point(json_Q)
print("TimeZone Done")
vecHours = c(14, 16, 4, 6)
vecHoursStr = c()
for(i in vecHours){
if(i + factor > 9){
vecHoursStr = c(vecHoursStr, toString(i + factor))
}else{
vecHoursStr = c(vecHoursStr, paste0("0",toString(i + factor)))
}
}
# json_Q = list()
# json_Q$date = "2023-08-06T00:00:00.000Z"
str_dt_Max = paste0(SimpleDate_point(json_Q$date), "T", vecHoursStr[1],":00:00.000Z")
end_dt_Max = paste0(SimpleDate_point(json_Q$date), "T", vecHoursStr[2],":00:00.000Z")
str_dt_Min = paste0(SimpleDate_point(json_Q$date), "T", vecHoursStr[3],":00:00.000Z")
end_dt_Min = paste0(SimpleDate_point(json_Q$date), "T", vecHoursStr[4],":00:00.000Z")
# MUDAR ISTO MAIS TARDE
# for(i in 1:length(grPais)){
#   if(json_Q$countryCode == grPais[i]){
#     idPais = toString(i)
#   }
# }
# str_dt_Max = "2024-12-16T14:00:00.000Z"
# end_dt_Max = "2024-12-16T16:00:00.000Z"
pdr_Max = GetProduct(str_dt_Max, end_dt_Max, json_Q$countryCode)
pdr_Min = GetProduct(str_dt_Min, end_dt_Min, json_Q$countryCode)
print("GetProducts Done")
state = GetState_point(pdr_Max, pdr_Min, json_Q$date)
Max_Lst = MaxLSTday_db_point(pdr_Max, input_shp)
Min_Lst = MinLSTday_db_point(pdr_Min, input_shp)
statMax = pointSelect(Max_Lst, json_Q)
statMin = pointSelect(Min_Lst, json_Q)
print("PointSelect Done")
df_geoj = list(lstPointID=json_Q$lstPointID, state=state, avg_min=statMin$Mean,
avg_max=statMax$Mean, sd_min=statMin$SD, sd_max=statMax$SD,
count_min=statMin$Count, count_max=statMax$Count)
str_geoj=jsonlite::toJSON(df_geoj, auto_unbox = TRUE, digits = 12, null = 'null')
return(str_geoj)
},
error = function(e){
print("Error")
state = 'error'
df_geoj = list(lstPointID=json_Q$lstPointID, state=state, avg_min=NULL,
avg_max=NULL, sd_min=NULL, sd_max=NULL,
count_min=NULL, count_max=NULL)
str_geoj = jsonlite::toJSON(df_geoj, auto_unbox = TRUE, digits = 12, null = 'null')
return(str_geoj)
}
)
#rm(state,df_geoj,str_geoj  )
# input_shp = GetWkt(json_Q, buff)
# print("WKT Done")
#
# factor = getTZdif(json_Q)
# print("TimeZone Done")
#
# vecHours = c(14, 16, 4, 6)
# vecHoursStr = c()
# for(i in vecHours){
#   if(i + factor > 9){
#     vecHoursStr = c(vecHoursStr, toString(i + factor))
#   }else{
#     vecHoursStr = c(vecHoursStr, paste0("0",toString(i + factor)))
#   }
# }
#
# str_dt_Max = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[1],":00:00.000Z")
# end_dt_Max = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[2],":00:00.000Z")
# str_dt_Min = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[3],":00:00.000Z")
# end_dt_Min = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[4],":00:00.000Z")
#
#
# # MUDAR ISTO MAIS TARDE
# for(i in 1:length(grPais)){
#   if(json_Q$countryCode == grPais[i]){
#     idPais = toString(i)
#   }
# }
#
# pdr_Max = GetProduct(str_dt_Max, end_dt_Max, idPais)
# pdr_Min = GetProduct(str_dt_Min, end_dt_Min, idPais)
# print("GetProducts Done")
#
# state = GetState(pdr_Max, pdr_Min)
#
# Max_Lst = MaxLSTday_db(pdr_Max, input_shp)
# Min_Lst = MinLSTday_db(pdr_Min, input_shp)
#
# statMax = pointSelect(Max_Lst, json_Q)
# statMin = pointSelect(Min_Lst, json_Q)
# print("PointSelect Done")
#
# df_geoj = list(lstPointID=json_Q$lstPointID, state=state, avg_min=statMin$Mean,
#                avg_max=statMax$Mean, sd_min=statMin$SD, sd_max=statMax$SD,
#                count_min=statMin$Count, count_max=statMax$Count)
#
# str_geoj=jsonlite::toJSON(df_geoj, auto_unbox = TRUE, digits = 12)
#devolve o json final
}
# MAIN
# define
percent_valid = 0.6
pixelsize = 1000
wgs = "+proj=longlat +datum=WGS84"
queue = 'lst-days'
update_queue = 'lst-days-update'
#redisConnect(host="localhost", port=6380)
req_Q = rRedis$LPOP(queue)
rRedis = redux::hiredis(redis_config(host="localhost", port=6380, timeout = 60 * 1000))
#redisConnect(host="localhost", port=6380)
req_Q = rRedis$LPOP(queue)
# Queue, pedido e json
json_Q = fromJSON(req_Q)
MaxMin = "max"; resol = pixelsize
asData = 0
#wkt e Max_Dist (para a interpolacao), usando UTM zone
input_shp = GetWkt(json_Q, 7000)
crop_Shp = terra::vect(json_Q$wkt, crs = wgs)
UTMzone = UTM_wkt(input_shp)
Max_Dist = max_dist_poly(input_shp, UTMzone)
factor = getTZdif(json_Q)
print(factor)
vecHours = c(14, 16, 4, 6)
vecHoursStr = c()
for(i in vecHours){
if(i + factor > 9){
vecHoursStr = c(vecHoursStr, toString(i + factor))
}else{
vecHoursStr = c(vecHoursStr, paste0("0",toString(i + factor)))
}
}
if(MaxMin == "max"){
str_dt = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[1],":00:00.000Z")
end_dt = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[2],":00:00.000Z")
}else if(MaxMin == "min"){
str_dt = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[3],":00:00.000Z")
end_dt = paste0(SimpleDate(json_Q$date), "T", vecHoursStr[4],":00:00.000Z")
}
# Connect DB, get products
# MUDAR ISTO MAIS TARDE
# for(i in 1:length(grPais)){
#   if(json_Q$countryCode == grPais[i]){
#     idPais = toString(i)
#   }
# }
pdr_minmax = GetProduct(str_dt, end_dt, json_Q$countryCode)
print('pdr_minmax')
if( length(pdr_minmax)>0 ){
asData = 1
}
in_json = pdr_minmax; valid_percent = percent_valid
# se nao existirem produtos retorna NA
if(length(in_json)==0){
return(NA)
}
# verifica data do produto para confirmar Quality Flag
if(as.Date(in_json[[1]]$date_product) >= as.Date("2021-04-26")){
newP = T
}else{
newP = F
}
# thesholds de qflags
q_thresh1 = 10000
q_thresh2 = c(101,102,301,302)
# se exitir 1 produto, retorna o mesmo
if(length(in_json)==1){
df = fromJSON(in_json[[1]]$data)
if(! class(df)== 'data.frame'){
df = fromJSON(df)
}
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
df = df_colNum(df)
reg_count = nrow(df)
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
if(nrow(df[!is.na(df$Lst),]) / reg_count >= valid_percent){
return(df)
}else{
return(NA)
}
}
# caso existam mais que 1 produto, encontra o max valido para cada ponto
df = fromJSON(in_json[[1]]$data)
class(df)
if(! class(df)== 'data.frame'){
df = fromJSON(df)
}
df
df = df_colNum(df)
names_c = colnames(df)
#colnames(df) = names_c
df = subset_product(df, input_shp)
df = df_colNum(df)
for(hour in 2:length(in_json)){
df_seq = fromJSON(in_json[[hour]]$data)
if(! class(df_seq)== 'data.frame'){
df_seq = fromJSON(df_seq)
}
df_seq = df_colNum(df_seq)
colnames(df_seq) =  names_c
df_seq = subset_product(df_seq, input_shp)
df_seq = df_colNum(df_seq)
for(i in 1:nrow(df_seq)){
if(newP){
if((df_seq$Lst[i] > df$Lst[i]) & (df_seq$Qflag[i] %in% q_thresh2)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}else{
if((df_seq$Lst[i] > df$Lst[i]) & (df_seq$Qflag[i] >= q_thresh1)){
df$Lst[i] = df_seq$Lst[i]
df$Qflag[i] = df_seq$Qflag[i]
}
}
}
}
colnames(df) = names_c
df = df_colNum(df)
reg_count = nrow(df)
if(newP){
df[!(df$Qflag %in% q_thresh2), "Lst"] = NA
}else{
df[df$Qflag < q_thresh1, "Lst"] = NA
}
queue
rRedis
redis$LLEN(queue)
rRedis$LLEN(queue)
rRedis$LLEN(lst-days-range)
rRedis$LLEN("lst-days-range")
MaxMin = "max"; resol = pixelsize
in_json = pdr_minmax; valid_percent = percent_valid
rRedis
rRedis$LLEN(queue)
queue = 'lst-days-range'
rRedis = redux::hiredis(redis_config(host="localhost", port=6380, timeout = 60 * 1000))
while(TRUE){
req_Q = rRedis$LPOP(queue)}
eq_Q = rRedis$LPOP(queue)
req_Q
rRedis$LLEN(queue)
rRedis$LLEN(queue)
rRedis$LLEN(queue)
rRedis$LLEN(queue)
rRedis$LLEN(queue)
index = "LST"
# stats
img_lst=finalRastMax$Rast_MinMax; img_clust=clusterDecMax
finalRastMax
queue
rRedis$LLEN(queue)
rRedis
rRedis$LLEN(queue)
rRedis$LLEN(queue)
queue
